<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Retro TV — Client</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html,body{margin:0;padding:0;width:100%;height:100%;background:black;overflow:hidden;}
  video,img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:black;}
  #pairing{position:absolute;left:0;right:0;bottom:0;width:100%;height:160px;padding:8px;font-family:monospace;font-size:12px;opacity:0.95;background:rgba(0,0,0,0.6);color:#fff;box-sizing:border-box;}
  #hint{position:absolute;bottom:168px;left:8px;color:#ddd;font-family:system-ui;font-size:13px;background:rgba(0,0,0,0.45);padding:6px 8px;border-radius:6px;}
  textarea{width:100%;height:100%;box-sizing:border-box;background:transparent;color:#fff;border:none;outline:none;resize:none;}
  #log{position:absolute;left:8px;top:8px;color:#ccc;font-family:monospace;font-size:12px;white-space:pre-wrap;}
</style>
</head>
<body>

<video id="player" autoplay playsinline controls></video>
<img id="maintenance" src="maintenance.png" alt="Maintenance screen" style="display:none;">

<div id="hint">Paste host offer SDP into the box below and press Enter — client's answer will replace it for copy/paste back to host.</div>
<div id="pairing"><textarea id="pairingText" placeholder="Paste host offer here and press Enter"></textarea></div>

<div id="log"></div>

<script>
(async function(){
  const player = document.getElementById('player');
  const maintenance = document.getElementById('maintenance');
  const pairingText = document.getElementById('pairingText');
  const logEl = document.getElementById('log');

  function log(...args){ logEl.textContent += args.map(String).join(' ') + '\n'; }

  const pc = new RTCPeerConnection({ bundlePolicy: 'max-bundle' });
  let dc = null;
  let incomingChunks = [];
  let incomingMeta = null;

  pc.ondatachannel = e => {
    dc = e.channel;
    dc.binaryType = 'arraybuffer';
    dc.onmessage = handleMessage;
    dc.onopen = () => log('DataChannel open (client)');
    dc.onclose = () => log('DataChannel closed (client)');
    dc.onerror = (e) => log('DataChannel error: ' + (e && e.message ? e.message : e));
  };

  // sanitize: light then aggressive fallback if necessary
  function sanitizeLight(sdp){
    return sdp.split(/\r?\n/).filter(line => {
      const t = line.trim();
      if (!t) return true;
      if (t.startsWith('a=max-message-size')) return false;
      if (t.startsWith('a=sctp-port')) return false;
      return true;
    }).join('\r\n');
  }
  function sanitizeAggressive(sdp){
    return sdp.split(/\r?\n/).filter(line => {
      const t = line.trim().toLowerCase();
      if (!t) return true;
      if (t.startsWith('a=max-message-size')) return false;
      if (t.startsWith('a=sctp-port')) return false;
      if (t.includes('sctp')) return false;
      if (t.includes('ice-options:trickle')) return false;
      return true;
    }).join('\r\n');
  }

  async function trySetRemoteDescriptionWithSanitizers(type, sdp){
    // raw
    try {
      await pc.setRemoteDescription({ type, sdp });
      return;
    } catch (err) {
      log('setRemoteDescription(raw) failed: ' + (err && err.message ? err.message : String(err)));
    }
    // light
    const light = sanitizeLight(sdp);
    if (light !== sdp) {
      try {
        await pc.setRemoteDescription({ type, sdp: light });
        log('Accepted after light sanitization.');
        return;
      } catch (err) {
        log('setRemoteDescription(light) failed: ' + (err && err.message ? err.message : String(err)));
      }
    }
    // aggressive
    const agg = sanitizeAggressive(sdp);
    if (agg !== light) {
      try {
        await pc.setRemoteDescription({ type, sdp: agg });
        log('Accepted after aggressive sanitization.');
        return;
      } catch (err) {
        log('setRemoteDescription(aggressive) failed: ' + (err && err.message ? err.message : String(err)));
      }
    }
    throw new Error('Failed to parse offer after sanitization attempts.');
  }

  // Wait for ICE gathering to finish helper
  function waitForIceComplete(timeoutMs = 10000){
    return new Promise(resolve => {
      if(pc.iceGatheringState === 'complete') return resolve();
      const t = setTimeout(()=> resolve(), timeoutMs);
      pc.onicegatheringstatechange = ()=> {
        if(pc.iceGatheringState === 'complete'){ clearTimeout(t); resolve(); }
      };
    });
  }

  function handleMessage(ev){
    if (typeof ev.data === 'string') {
      try {
        const obj = JSON.parse(ev.data);
        if (obj.end) {
          const blob = new Blob(incomingChunks, { type: incomingMeta?.type || 'video/mp4' });
          const url = URL.createObjectURL(blob);
          player.src = url;
          player.onended = () => {
            maintenance.style.display = '';
            player.style.display = 'none';
            setTimeout(()=> {
              URL.revokeObjectURL(url);
              player.src = '';
            }, 1000);
          };
          maintenance.style.display = 'none';
          player.style.display = '';
          player.play().catch(()=>{ /* autoplay may be blocked; user can tap to play */ });
          incomingChunks = [];
          incomingMeta = null;
        } else {
          incomingMeta = obj;
          incomingChunks = [];
        }
      } catch(e) {
        log('JSON parse error on text message: ' + String(e));
      }
    } else {
      incomingChunks.push(ev.data);
    }
  }

  // Enter key creates an answer: user pastes offer -> press Enter
  pairingText.addEventListener('keydown', async (ev) => {
    if (ev.key !== 'Enter') return;
    ev.preventDefault();
    const rawOffer = pairingText.value.trim();
    if (!rawOffer) return;
    try {
      await trySetRemoteDescriptionWithSanitizers('offer', rawOffer);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await waitForIceComplete(10000);
      // Put the answer SDP back in the text area so the user can copy it to the host
      pairingText.value = pc.localDescription.sdp;
      try { await navigator.clipboard.writeText(pc.localDescription.sdp); log('Answer copied to clipboard (if allowed)'); } catch(e){}
      log('Answer created. Paste it back to the host.');
      // hide pairing box shortly after so user sees the result
      setTimeout(()=> { pairingText.parentElement.style.display = 'none'; }, 1200);
    } catch (err) {
      const msg = err && err.message ? err.message : String(err);
      log('Pairing/createAnswer failed: ' + msg);
      pairingText.value = 'Error creating answer: ' + msg + '\n\nOriginal offer was left above for debugging.\n\n';
    }
  });

  // Keep maintenance visible until playback begins
  maintenance.style.display = '';
  player.style.display = 'none';
})();
</script>
</body>
</html>